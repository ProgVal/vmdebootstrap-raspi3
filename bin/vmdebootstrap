#! /usr/bin/python
# Copyright 2011-2013  Lars Wirzenius
# Copyright 2012  Codethink Limited
# Copyright 2014-2015 Neil Williams <codehelp@debian.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import sys
import time
import shutil
import cliapp
import logging
import datetime
import tempfile
import subprocess
from vmdebootstrap.base import (
    Base,
    runcmd,
    cleanup_apt_cache,
)
from vmdebootstrap.grub import GrubHandler
from vmdebootstrap.extlinux import ExtLinux
from vmdebootstrap.codenames import Codenames
from vmdebootstrap.filesystem import Filesystem
from vmdebootstrap.uefi import Uefi, arch_table


__version__ = '1.0'

# pylint: disable=invalid-name,line-too-long,missing-docstring


class VmDebootstrap(cliapp.Application):  # pylint: disable=too-many-public-methods

    def __init__(self, progname=None, version=__version__, description=None, epilog=None):
        super(VmDebootstrap, self).__init__(progname, version, description, epilog)
        self.remove_dirs = []
        self.mount_points = []
        self.bootdir = None
        self.handlers = {
            Base.name: Base(),
            Uefi.name: Uefi(),
            Codenames.name: Codenames(),
            GrubHandler.name: GrubHandler(),
            ExtLinux.name: ExtLinux(),
            Filesystem.name: Filesystem(),
        }

    def add_settings(self):
        default_arch = subprocess.check_output(
            ["dpkg", "--print-architecture"]).strip()

        self.settings.boolean(
            ['verbose'], 'report what is going on')
        self.settings.string(
            ['image'], 'put created disk image in FILE',
            metavar='FILE')
        self.settings.bytesize(
            ['size'], 'create a disk image of size SIZE (%default)',
            metavar='SIZE', default='1G')
        self.settings.bytesize(
            ['bootsize'], 'create boot partition of size '
            'SIZE (%default)',
            metavar='BOOTSIZE', default='0%')
        self.settings.string(
            ['boottype'], 'specify file system type for /boot/',
            default='ext2')
        self.settings.bytesize(
            ['bootoffset'], 'Space to leave at start of the '
            'image for bootloader',
            default='0')
        self.settings.boolean(
            ['use-uefi'], 'Setup image for UEFI boot',
            default=False)
        self.settings.bytesize(
            ['esp-size'], 'Size of EFI System Partition - '
            'requires use-uefi',
            default='5mib')
        self.settings.string(
            ['part-type'], 'Partition type to use for this image',
            default='msdos')
        self.settings.string(
            ['roottype'], 'specify file system type for /',
            default='ext4')
        self.settings.bytesize(
            ['swap'], 'create swap space of size SIZE (min 256Mb)')
        self.settings.string(
            ['foreign'], 'set up foreign debootstrap environment '
            'using provided program (ie binfmt handler)')
        self.settings.string(
            ['variant'], 'select debootstrap variant it not using '
            'the default')
        self.settings.boolean(
            ['extlinux'], 'install extlinux?',
            default=True)
        self.settings.string(
            ['tarball'], "tar up the disk's contents in FILE",
            metavar='FILE')
        self.settings.string(
            ['apt-mirror'], 'configure apt to use MIRROR',
            metavar='URL')
        self.settings.string(
            ['mirror'], 'use MIRROR as package source (%default)',
            metavar='URL',
            default='http://http.debian.net/debian/')
        self.settings.string(
            ['arch'], 'architecture to use (%default)',
            metavar='ARCH',
            default=default_arch)
        self.settings.string(
            ['distribution'], 'release to use (%default)',
            metavar='NAME',
            default='stable')
        self.settings.string_list(
            ['package'], 'install PACKAGE onto system')
        self.settings.string_list(
            ['custom-package'], 'install package in DEB file '
            'onto system (not from mirror)',
            metavar='DEB')
        self.settings.boolean(
            ['no-kernel'], 'do not install a linux package')
        self.settings.string(
            ['kernel-package'], 'install PACKAGE instead of '
            'the default kernel package',
            metavar='PACKAGE')
        self.settings.boolean(
            ['enable-dhcp'], 'enable DHCP on eth0')
        self.settings.string(
            ['root-password'], 'set root password',
            metavar='PASSWORD')
        self.settings.boolean(
            ['lock-root-password'], 'lock root account so they '
            'cannot login?')
        self.settings.string(
            ['customize'], 'run SCRIPT after setting up system',
            metavar='SCRIPT')
        self.settings.string(
            ['hostname'], 'set name to HOSTNAME (%default)',
            metavar='HOSTNAME',
            default='debian')
        self.settings.string_list(
            ['user'], 'create USER with PASSWORD',
            metavar='USER/PASSWORD')
        self.settings.boolean(
            ['serial-console'], 'configure image to use a serial console')
        self.settings.string(
            ['serial-console-command'], 'command to manage the '
            'serial console, appended to /etc/inittab (%default)',
            metavar='COMMAND',
            default='/sbin/getty -L ttyS0 115200 vt100')
        self.settings.boolean(
            ['sudo'], 'install sudo, and if user is created, '
            'add them to sudo group')
        self.settings.string(
            ['owner'], 'the user who will own the image when '
            'the build is complete.')
        self.settings.boolean(
            ['squash'], 'use squashfs on the final image.')
        self.settings.boolean(
            ['configure-apt'], 'Create an apt source based on '
            'the distribution and mirror selected.')
        self.settings.boolean(
            ['mbr'], 'Run install-mbr (default if extlinux used)')
        self.settings.boolean(
            ['grub'], 'Install and configure grub2 - '
            'disables extlinux.')
        self.settings.boolean(
            ['sparse'], 'Do not fill the image with zeros to '
            'keep a sparse disk image',
            default=False)
        self.settings.boolean(
            ['pkglist'], 'Create a list of package names '
            'included in the image.')
        self.settings.boolean(
            ['no-acpid'], 'do not install the acpid package',
            default=False)

    def process_args(self, args):  # pylint: disable=too-many-branches,too-many-statements

        for _, handler in self.handlers.items():
            handler.define_settings(self.settings)

        distro = self.handlers[Codenames.name]
        if not self.settings['image'] and not self.settings['tarball']:
            raise cliapp.AppException(
                'You must give disk image filename, or tarball filename')
        if self.settings['image'] and not self.settings['size']:
            raise cliapp.AppException(
                'If disk image is specified, you must give image size.')
        if not distro.debian_info.valid(self.settings['distribution']):
            if not distro.ubuntu_info.valid(self.settings['distribution']):
                raise cliapp.AppException(
                    '%s is not a valid Debian or Ubuntu suite or codename.'
                    % self.settings['distribution'])
        if not self.settings['use-uefi'] and self.settings['esp-size'] != 5242880:
            raise cliapp.AppException(
                'You must specify use-uefi for esp-size to have effect')
        if arch_table[self.settings['arch']]['exclusive'] and\
                not self.settings['use-uefi']:
            raise cliapp.AppException(
                'Only UEFI is supported on %s' % self.settings['arch'])
        elif self.settings['use-uefi'] and self.settings['arch'] not in arch_table:
            raise cliapp.AppException(
                '%s is not a supported UEFI architecture' % self.settings['arch'])
        if self.settings['use-uefi'] and (
                self.settings['bootsize'] or
                self.settings['bootoffset']):
            raise cliapp.AppException(
                'A separate boot partition is not supported with UEFI')

        if self.settings['use-uefi'] and not self.settings['grub']:
            raise cliapp.AppException(
                'UEFI without Grub is not supported.')

        # wheezy (which became oldstable on 04/25/2015) only had amd64 uefi
        if distro.was_oldstable(datetime.date(2015, 4, 26)):
            if self.settings['arch'] != 'amd64':
                raise cliapp.AppException(
                    'Only amd64 supports UEFI in Wheezy')

        if os.geteuid() != 0:
            sys.exit("You need to have root privileges to run this script.")
        self.start_ops()

    def _image_preparations(self):
        uefi = self.handlers[Uefi.name]
        base = self.handlers[Base.name]
        filesystem = self.handlers[Filesystem.name]
        extlinux = self.handlers[ExtLinux.name]
        base.create_empty_image()
        self.partition_image()
        extlinux.install_mbr()
        filesystem.setup_kpartx()
        rootdev = filesystem.devices['rootdev']
        roottype = filesystem.devices['roottype']
        bootdev = filesystem.devices['bootdev']
        if self.settings['swap'] > 0:
            self.message("Creating swap space")
            runcmd(['mkswap', filesystem.devices['swapdev']])
        filesystem.mkfs(rootdev, fstype=roottype)
        rootdir = self.mount(rootdev)
        filesystem.devices['rootdir'] = rootdir
        if self.settings['use-uefi']:
            self.mount(bootdev, uefi.prepare_esp(rootdir, bootdev))
        elif bootdev:
            boottype = self.settings['boottype']
            filesystem.mkfs(bootdev, fstype=boottype)
            self.bootdir = '%s/%s' % (rootdir, 'boot/')
            os.mkdir(self.bootdir)
            self.mount(bootdev, self.bootdir)

    def _image_operations(self, rootdir, rootdev):
        if not self.settings['image']:
            return
        logging.debug("rootdir=%s rootdev=%s", rootdir, rootdev)
        grub = self.handlers[GrubHandler.name]
        extlinux = self.handlers[ExtLinux.name]
        base = self.handlers[Base.name]
        filesystem = self.handlers[Filesystem.name]
        if self.settings['use-uefi']:
            grub.install_grub_uefi(rootdir)
            uefi.configure_efi()
            grub.install_extra_grub_uefi(rootdir)
            uefi.configure_extra_efi()
        elif self.settings['grub']:
            if not grub.install_grub2(rootdev, rootdir):
                extlinux.install_extlinux(rootdev, rootdir)
        elif self.settings['extlinux']:
            extlinux.install_extlinux(rootdev, rootdir)
        base.append_serial_console(rootdir)
        self.optimize_image(rootdir)
        filesystem.squash()

    def start_ops(self):
        base = self.handlers[Base.name]
        filesystem = self.handlers[Filesystem.name]
        try:
            if self.settings['image']:
                self._image_preparations()
                rootdir = filesystem.devices['rootdir']
                rootdev = filesystem.devices['rootdev']
            else:
                rootdir = self.mkdtemp()
            logging.debug("rootdir=%s rootdev=%s", rootdir, rootdev)
            self.debootstrap(rootdir)
            filesystem.set_hostname()
            filesystem.create_fstab()
            self.install_debs(rootdir)
            base.set_root_password(rootdir)
            base.create_users(rootdir)
            filesystem.remove_udev_persistent_rules()
            self.setup_networking(rootdir)
            filesystem.configure_apt()
            base.customize(rootdir)
            cleanup_apt_cache(rootdir)
            filesystem.update_initramfs()
            self._image_operations(rootdir, rootdev)
            filesystem.list_installed_pkgs()

            if self.settings['foreign']:
                os.unlink(
                    '%s/usr/bin/%s' %
                    (rootdir, os.path.basename(self.settings['foreign'])))

            if self.settings['tarball']:
                base.create_tarball(rootdir)
            filesystem.chown()

        except BaseException as e:
            self.message('EEEK! Something bad happened...')
            if rootdir:
                db_log = os.path.join(rootdir, 'debootstrap', 'debootstrap.log')
                if os.path.exists(db_log):
                    shutil.copy(db_log, os.getcwd())
            self.message(e)
            self.cleanup_system()
            raise
        else:
            self.cleanup_system()

    def message(self, msg):
        logging.info(msg)
        if self.settings['verbose']:
            print msg

    def runcmd(self, argv, stdin='', ignore_fail=False, env=None, **kwargs):
        logging.debug('runcmd: %s %s %s', argv, env, kwargs)
        p = subprocess.Popen(argv, stdin=subprocess.PIPE,
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                             env=env, **kwargs)
        out, err = p.communicate(stdin)
        if p.returncode != 0:
            msg = 'command failed: %s\n%s\n%s' % (argv, out, err)
            logging.error(msg)
            if not ignore_fail:
                raise cliapp.AppException(msg)
        return out

    def mkdtemp(self):
        dirname = tempfile.mkdtemp()
        self.remove_dirs.append(dirname)
        logging.debug('mkdir %s', dirname)
        return dirname

    def mount(self, device, path=None):
        if not path:
            mount_point = self.mkdtemp()
        else:
            mount_point = path
        self.message('Mounting %s on %s' % (device, mount_point))
        runcmd(['mount', device, mount_point])
        self.mount_points.append(mount_point)
        logging.debug('mounted %s on %s', device, mount_point)
        return mount_point

    def partition_image(self):
        """
        Uses fat16 (msdos) partitioning by default, use part-type to change.
        If bootoffset is specified, the first actual partition
        starts at that offset to allow customisation scripts to
        put bootloader images into the space, e.g. u-boot.
        """
        self.message('Creating partitions')
        runcmd(['parted', '-s', self.settings['image'],
                'mklabel', self.settings['part-type']])
        partoffset = 0
        extent = '100%'
        swap = 256 * 1024 * 1024
        if self.settings['swap'] > 0:
            if self.settings['swap'] > swap:
                swap = self.settings['swap']
            else:
                # minimum 256Mb as default qemu ram is 128Mb
                logging.debug("Setting minimum 256Mb swap space")
            extent = "%s%%" % int(100 * (self.settings['size'] - swap) / self.settings['size'])

        if self.settings['use-uefi']:
            uefi = self.handlers[Uefi.name]
            uefi.partition_esp()

        if self.settings['bootoffset'] and self.settings['bootoffset'] is not '0':
            # turn v.small offsets into something at least possible to create.
            if self.settings['bootoffset'] < 1048576:
                partoffset = 1
                logging.info(
                    "Setting bootoffset %smib to allow for %s bytes",
                    partoffset, self.settings['bootoffset'])
            else:
                partoffset = self.settings['bootoffset'] / (1024 * 1024)
                self.message("Using bootoffset: %smib %s bytes" % (partoffset, self.settings['bootoffset']))
        if self.settings['bootsize'] and self.settings['bootsize'] is not '0%':
            if self.settings['grub'] and not partoffset:
                partoffset = 1
            bootsize = self.settings['bootsize'] / (1024 * 1024)
            bootsize += partoffset
            self.message("Using bootsize %smib: %s bytes" % (bootsize, self.settings['bootsize']))
            logging.debug("Starting boot partition at %sMb", bootsize)
            runcmd(['parted', '-s', self.settings['image'],
                    'mkpart', 'primary', 'fat16', str(partoffset), str(bootsize)])
            logging.debug("Starting root partition at %sMb", partoffset)
            runcmd(['parted', '-s', self.settings['image'],
                    'mkpart', 'primary', str(bootsize), extent])
        elif self.settings['use-uefi']:
            bootsize = self.settings['esp-size'] / (1024 * 1024) + 1
            runcmd(['parted', '-s', self.settings['image'],
                    'mkpart', 'primary', str(bootsize), extent])
        else:
            runcmd(['parted', '-s', self.settings['image'],
                    'mkpart', 'primary', '0%', extent])
        runcmd(['parted', '-s', self.settings['image'],
                'set', '1', 'boot', 'on'])
        if self.settings['swap'] > 0:
            logging.debug("Creating swap partition")
            runcmd(['parted', '-s', self.settings['image'],
                    'mkpart', 'primary', 'linux-swap', extent, '100%'])

    def _bootstrap_packages(self):  # pylint: disable=too-many-branches
        uefi = self.handlers[Uefi.name]
        distro = self.handlers[Codenames.name]
        include = self.settings['package']

        if not self.settings['foreign'] and not self.settings['no-acpid']:
            include.append('acpid')

        if self.settings['grub']:
            if self.settings['use-uefi']:
                include.extend(uefi.efi_packages())
            else:
                include.append('grub-pc')

        if not self.settings['no-kernel']:
            if self.settings['kernel-package']:
                kernel_image = self.settings['kernel-package']
            else:
                if self.settings['arch'] == 'i386':
                    # wheezy (which became oldstable on 04/25/2015) used '486'
                    if distro.was_oldstable(datetime.date(2015, 4, 26)):
                        kernel_arch = '486'
                    else:
                        kernel_arch = '586'
                elif self.settings['arch'] == 'armhf':
                    kernel_arch = 'armmp'
                else:
                    kernel_arch = self.settings['arch']
                kernel_image = 'linux-image-%s' % kernel_arch
            include.append(kernel_image)

        if self.settings['sudo'] and 'sudo' not in include:
            include.append('sudo')

        return include

    def _debootstrap_second_stage(self, rootdir):
        # set a noninteractive debconf environment for secondstage
        env = {
            "DEBIAN_FRONTEND": "noninteractive",
            "DEBCONF_NONINTERACTIVE_SEEN": "true",
            "LC_ALL": "C"
        }
        # add the mapping to the complete environment.
        env.update(os.environ)
        # First copy the binfmt handler over
        self.message('Setting up binfmt handler')
        shutil.copy(self.settings['foreign'], '%s/usr/bin/' % rootdir)
        # Next, run the package install scripts etc.
        self.message('Running debootstrap second stage')
        runcmd(['chroot', rootdir,
                '/debootstrap/debootstrap', '--second-stage'],
               env=env)

    def debootstrap(self, rootdir):
        msg = "(%s)" % self.settings['variant'] if self.settings['variant'] else ''
        self.message(
            'Debootstrapping %s [%s] %s' % (
                self.settings['distribution'], self.settings['arch'], msg))
        include = self._bootstrap_packages()

        args = ['debootstrap', '--arch=%s' % self.settings['arch']]

        if self.settings['package']:
            args.append(
                '--include=%s' % ','.join(include))
        if self.settings['foreign']:
            args.append('--foreign')
        if self.settings['variant']:
            args.append('--variant')
            args.append(self.settings['variant'])
        args += [self.settings['distribution'],
                 rootdir, self.settings['mirror']]
        logging.debug(" ".join(args))
        runcmd(args)
        if self.settings['foreign']:
            self._debootstrap_second_stage(rootdir)

    def install_debs(self, rootdir):
        if not self.settings['custom-package']:
            return
        self.message('Installing custom packages')
        tmp = os.path.join(rootdir, 'tmp', 'install_debs')
        os.mkdir(tmp)
        for deb in self.settings['custom-package']:
            shutil.copy(deb, tmp)
        filenames = [os.path.join('/tmp/install_debs', os.path.basename(deb))
                     for deb in self.settings['custom-package']]
        out, err, _ = \
            self.runcmd_unchecked(['chroot', rootdir, 'dpkg', '-i'] + filenames)
        logging.debug('stdout:\n%s', out)
        logging.debug('stderr:\n%s', err)
        out = runcmd(['chroot', rootdir,
                      'apt-get', '-f', '--no-remove', 'install'])
        logging.debug('stdout:\n%s', out)
        shutil.rmtree(tmp)

    def optimize_image(self, rootdir):
        """
        Filing up the image with zeros will increase its compression rate
        """
        if not self.settings['sparse']:
            zeros = os.path.join(rootdir, 'ZEROS')
            self.runcmd_unchecked(['dd', 'if=/dev/zero', 'of=' + zeros, 'bs=1M'])
            runcmd(['rm', '-f', zeros])

    def setup_networking(self, rootdir):
        self.message('Setting up networking')
        distro = self.handlers[Codenames.name]
        # unconditionally write for wheezy (which became oldstable on 04/25/2015)
        if distro.was_oldstable(datetime.date(2015, 4, 26)):
            with open(os.path.join(rootdir, 'etc', 'network', 'interfaces'), 'w') as netfile:
                netfile.write('source /etc/network/interfaces.d/*\n')
            os.mkdir(os.path.join(rootdir, 'etc', 'network', 'interfaces.d'))

        elif not os.path.exists(os.path.join(rootdir, 'etc', 'network', 'interfaces')):
            iface_path = os.path.join(rootdir, 'etc', 'network', 'interfaces')
            with open(iface_path, 'w') as netfile:
                netfile.write('source-directory /etc/network/interfaces.d\n')
        ethpath = os.path.join(rootdir, 'etc', 'network', 'interfaces.d', 'setup')
        with open(ethpath, 'w') as eth:
            eth.write('auto lo\n')
            eth.write('iface lo inet loopback\n')

            if self.settings['enable-dhcp']:
                eth.write('\n')
                eth.write('auto eth0\n')
                eth.write('iface eth0 inet dhcp\n')

    def cleanup_system(self):
        # Clean up after any errors.

        self.message('Cleaning up')

        # Umount in the reverse mount order
        if self.settings['image']:
            for i in range(len(self.mount_points) - 1, -1, -1):
                mount_point = self.mount_points[i]
                try:
                    runcmd(['umount', mount_point], ignore_fail=False)
                except cliapp.AppException:
                    logging.debug("umount failed, sleeping and trying again")
                    time.sleep(5)
                    runcmd(['umount', mount_point], ignore_fail=False)

            runcmd(['kpartx', '-d', self.settings['image']], ignore_fail=True)

        for dirname in self.remove_dirs:
            shutil.rmtree(dirname)

if __name__ == '__main__':
    VmDebootstrap(version=__version__).run()
